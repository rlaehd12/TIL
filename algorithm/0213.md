# INDEX

- [INDEX](#index)
  - [스택](#스택)
  - [재귀호출](#재귀호출)
  - [Memoziation](#memoziation)
  - [DP](#dp)
  - [DFS](#dfs)

## 스택

* 자료를 쌓아 올린 형태의 자료구조

* 스택에 저장된 자료는 선형 구조를 가짐

  * 선형 : 자료 간의 관계가 1대1의 관계

  * 비선형: 자료 간의 관계가 1대N의 관계(예: 트리)

* 스택에 자료를 삽입하거나 자료를 꺼낼 수 있다.

* 마지막에 삽입한 자료를 가장 먼저 꺼낸다. 후입선출(LIFO, Last-In-First_Out)이라고 부름

> 스택을 프로그램에서 구현하기 위해 필요한 자료구조와 연산

* 자료구조 : 자료를 선형으로 저장할 저장소
  * 파이썬은 배열 사용 가능

  * 저장소 자체를 스택이라 부르기도 함

  * 스택에서 마지막 삽입된 원소의 위치를 top이라 부른다.

* 연산

  * 삽입 : 저장소에 자료를 저장한다. 보통 push

  * 삭제 : 저장소에서 자료를 꺼낸다. 꺼낸 자료는 삽입한 자료의 역순으로 꺼냄. 보통 pop

  * 스택이 공백인지 확인, isEmpty

  * 스택의 top에 있는 item을 반환하는 연산, peek

> 스택 구현

* push 알고리즘
  * append 활용 - 느림
  * 스택의 크기 정해놓고 활용

  ```python
  def push(item, size):
      global top
      top += 1
      if top == size:
          pass
      else:
          stack[top] = item
  ```

* pop 알고리즘

    ```python
    def pop():
        if top == -1:  # 아무것도 없을 때
            return 0
        else:
            top -= 1
            return stack[top+1]
    ```

> 스택 구현 고려사항

* 1차원 배열을 사용할 경우 구현이 용이하지만 스택의 크기를 변경하기 어렵다는 단점

* 이를 해결하기 위한 방법으로 저장소를 동적으로 할당하여 스택을 구현하는 방법, 동적 연결리스트를 활용해 구현하는 방법을 의미.  
구현이 복잡하다는 단점이 있지만 메모리를 효율적으로 사용한다는 장점을 가짐

> 스택 응용 : function call

* 프로그램에서 함수 호출과 복귀에 따른 수행 순서 관리

  * 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조이므로, 후입선출 구조의 스택을 이용하여 수행순서 관리

  * 함수 호출이 발생하면 호출한 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임(stack frame)에 저장하여 시스템 스택에 삽입

  * 함수의 실행이 끝나면 시스템 스택의 top 원소(스택 프레임)를 삭제(pop)하면서 프레임에 저장되어 있던 복귀주소를 확인하고 복귀

  * 함수 호출과 복귀에 따라 이 과정을 반복하여 전체 프로그램이 종료되면 시스템 스택은 공백 스택이 된다.

* 함수 호출과 복귀에 따른 전체 프로그램 수행 순서

  <img src = https://user-images.githubusercontent.com/122508528/218360526-7220d860-b6ad-4029-8cf8-fa52b129a0a5.png width= 550>

## 재귀호출

* 자기 자신을 호출하여 순환 수행되는 것

* 함수를 부를때 메모리 영역이 구분되니 같은 함수여도 다른거 취급됨

* 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀호출방식을 사용하여 함수를 만들면 프로그램 크기 줄이고 간단하게 작성

  * 예시 : factorial

    ```python
    n! = n * (n-1)!
      (n-1)! = (n-1) * (n-2)!
      (n-2)! = (n-2) * (n-3)!
    ...
      2! = 2 * 1!
      1! = 1
    ```

    * 마지막에 구한 값을 이용해 상위 값을 구하는 작업 반복
  
  * 피보나치 수를 구하는 재귀함수

    ```python
    def fibo(n):
        if n < 2:
            return n
        else:
            return fibo(n-1) + fibo(n-2)
    ```

* 재귀호출 기본 구조
  * 기본적으로 2개 인자 가짐

  ```python
  def func(i, k):  # i 현재 단계, k 목표
      if i == k:  # 목표 도달
          return
      else:
          return func(i+1, k)  # 다음 단계
  ```

## Memoziation

* 메모이제이션(Memoziation)은 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해 매번 다시 계산하지 않도록 하여 전체적인 실행 속도를 빠르게 하는 기술, 동적 계획법의 핵심.

* 메모이제이션은 글자 그대로 해석하면 '메모리에 넣기(to put in memory)' 라는 의미, '기억해야 될 것' 이라는 라틴어 memorandum에서 파생됨

* 앞의 예에서 구현한 피보나치에서 fibo(n)을 계산하자마자 저장하면(memorize), 실행시간을 $O(n)$ 으로 줄일 수 있다.

* memoziation 적용 예

  ```python
  # memo를 위한 배열 할당, 모두0으로 초기화
  # memo[0]을 0으로, memo[1]을 1로 초기화
  def fibo1(n):
      global memo
      if n >= 2 and memo[n] == 0:
          memo[n] = (fibo(n-1) + fibo(n-2))
      return memo[n]
  
  memo = [0] * (n+1)
  memo[0] = 0
  memo[1] = 1
  ```

## DP

* 동적계획(Dynamic Programming) 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘

* 동적 계획 알고리즘은 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 문제를 해결해, 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘

* 점화식이 상당히 많음

* 피보나치 수 DP 적용
  * 피보나치수는 부분 문제의 답으로부터 본 문제의 답을 얻을 수 있으므로 최적 부분 구조로 이루어짐

  1. 문제를 부분 문제로 분할
  2. 부분 문제로 나누는 일을 끝냈으면 가장 작은 부분 문제의 해를 구함
  3. 그 결과는 테이블에 저장, 테이블의 저장된 부분 문제의 해를 이용해 상위 문제의 해를 구한다.

  ```python
  def fibo2(n):
      f = [0] * (n+1)
      f[0] = 0
      f[1] = 1
      for i in range(2, n+1):
          f[i] = f[i-1] + f[i-2]
      return f[n]
  ```

* DP의 구현 방식
  * recursive(재귀) 방식, fibo1
  * iterative(반복) 방식, fibo2

  * 메모이제이션을 재귀적 구조에 사용하는 것보다 반복적 구조로 DP를 구현하는 것이 성능 면에서 보다 효율적
  * 재귀적 구조는 내부에 시스템 호출 스택을 사용하는 오버헤드가 발생하기 때문

## DFS

* 비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요
* 두가지 방법
  * DFS, 깊이 우선 탐색
  * BFS, 너비 우선 탐색

* DFS
  * 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없으면, 가장 마지막에 만났던 갈림길 edge가 있는 vertices로 되돌아와 다른 방향의 정점으로 탐색을 계속 반복해 모든 정점을 방문하는 순회방법

  * 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택 사용

> DFS 알고리즘

1. 시작 정점 v를 결정하여 방문

2. 정점 v에 인접한 정점 중에서

    * 방문하지 않은 정점 w가 있으면, 정점 v를 스택에 쌓고 정점 w를 방문, 그리고 w를 v로 하여 다시 2 반복

    * 방문하지 않은 정점이 없다면, 탐색의 방향을 바꾸기 위해 스택을 pop하여, 받은 가장 마지막 방문 정점을 v로 하여 다시 2 반복

3. 스택이 공백이 될때까지 2를 반복

* 의사코드

  ```c
  DFS(v)
      visited[v] = True
      while{
          if (v의 인접 정점 중 방문 안한 정점 w이 있으면)
              push(v)
              v = w
              visited[w] = True
          else
              if (스택이 비어있지 않다면)
                  v = stack.pop()
              else
                  break
      }
  ```

* [DFS 구현 예시](https://github.com/rlaehd12/TIL/blob/main/algorithm/DFS.py)