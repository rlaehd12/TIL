# INDEX

* [알고리즘](#알고리즘)
* [배열](#배열)
* [버블정렬](#버블정렬)
* [카운팅 정렬](#카운팅-정렬)
* [완전검색](#완전검색)
* [그리디](#그리디)

## 알고리즘

* 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법  
주로 컴퓨터 언어로 쓰이며 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법
* 어떤 문제를 해결하기 위한 절차

* 알고리즘 표현하는 방법 크게 두가지
  * 의사코드(슈도코드, pseudocode)

    ```python
    # 구구단 2단부터 9단까지 출력 의사코드 예시
    반복문 시작 (a를 2에서 9까지)
        반복문 시작 (b를 1에서 9까지)
            출력 : a * b  = 값 (개행)
        반복문 종료
    반복문 종료
    ```

  * 순서도

* 좋은 알고리즘?
  * 정확성 : 얼마나 정확하게 동작하는가
  * 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
  * 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
  * 단순성 : 얼마나 단순하가
  * 최적성 : 더이상 개선할 여지 없이 최적화 되었나

* 알고리즘의 성능 분석
  * 많은 문제에서 성능 분석 기준으로 알고리즘 작업량을 비교
  * 알고리즘의 작업량을 표현할 때 시간복잡도로 표현

  > 시간 복잡도

  * 실제 걸리는 시간 측정
  * 실행되는 명령문 개수를 계산
  * **빅-오(O) 표기법**
    * 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
    * 계수(Coeffcient) 는 생략하여 표시
    <img src="https://t1.daumcdn.net/cfile/tistory/2132384B5767C05006" alt="drawing" width="500"/>

## 배열

* 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
  * 연속적인 메모리에 할당

* 필요성
  * 프로그램 내 여러 변수가 필요할 때, 일일이 다른 변수명 이용해 자료에 접근하는 것은 매우 비효율적
  * 배열을 사용하면 하나의 선언을 통해 둘 이상의 변수 선언 가능
  * 단순히 다수의 변수 선언을 의미하는 것이 아니라, 다수의 변수로 하기 힘든 작업을 배열을 통해 쉽게 할 수 있다.

* 1차원 배열 선언
  * 별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성
  * 이름 : 프로그램에서 사용할 배열의 이름
* 1차원 배열 접근
  * 인덱스를 사용하거나 변수를 사용해 접근 `arr[0]`

## 버블정렬

* 정렬
  * 2개 이상의 자료를 특정 기준에 따라 큰값 또는 그 반대로 재배열 하는 것

  * 키
    * 자료를 정렬하는 기준이 되는 특정 값

* 대표적인 정렬 방식
  * **버블 정렬**
  * 카운팅 정렬
  * **선택 정렬**
  * 퀵 정렬
  * 삽입 정렬
  * 병합 정렬

> 버블 정렬

* 인접한 두개의 원소를 비교하여 자리를 계속 교환하는 방식
* 정렬 과정
  * 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환해 맨 마지막 자리까지 이동
  * 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 이동됨
  * 모두 정렬될 때까지 단계 반복
  * 교환하며 자리 이동하는 모습이 물 위로 올라오는 거품 모양과 비슷해 거품정렬
* 시간복잡도 : O(n^2)

* 의사코드

    ```c
    bubbleSort(){
        ary[SIZE]
        for i = 1 to SIZE{
            for j = 1 to SIZE-i{
                if(ary[j-1] > ary[j])
                    swap(ary[j-1], ary[j])
            }
        }
    }
    ```

## 카운팅 정렬

## 완전검색

## 그리디
