# INDEX

* [알고리즘](#알고리즘)
* [배열](#배열)
* [버블정렬](#버블정렬)
* [카운팅 정렬](#카운팅-정렬)
* [완전검색](#완전검색)
* [그리디](#그리디)

## 알고리즘

* 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법  
주로 컴퓨터 언어로 쓰이며 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법
* 어떤 문제를 해결하기 위한 절차

* 알고리즘 표현하는 방법 크게 두가지
  * 의사코드(슈도코드, pseudocode)

    ```python
    # 구구단 2단부터 9단까지 출력 의사코드 예시
    반복문 시작 (a를 2에서 9까지)
        반복문 시작 (b를 1에서 9까지)
            출력 : a * b  = 값 (개행)
        반복문 종료
    반복문 종료
    ```

  * 순서도

* 좋은 알고리즘?
  * 정확성 : 얼마나 정확하게 동작하는가
  * 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
  * 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
  * 단순성 : 얼마나 단순하가
  * 최적성 : 더이상 개선할 여지 없이 최적화 되었나

* 알고리즘의 성능 분석
  * 많은 문제에서 성능 분석 기준으로 알고리즘 작업량을 비교
  * 알고리즘의 작업량을 표현할 때 시간복잡도로 표현

  > 시간 복잡도

  * 실제 걸리는 시간 측정
  * 실행되는 명령문 개수를 계산
  * **빅-오(O) 표기법**
    * 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
    * 계수(Coeffcient) 는 생략하여 표시
    <img src="https://t1.daumcdn.net/cfile/tistory/2132384B5767C05006" alt="drawing" width="500"/>

## 배열

* 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
  * 연속적인 메모리에 할당

* 필요성
  * 프로그램 내 여러 변수가 필요할 때, 일일이 다른 변수명 이용해 자료에 접근하는 것은 매우 비효율적
  * 배열을 사용하면 하나의 선언을 통해 둘 이상의 변수 선언 가능
  * 단순히 다수의 변수 선언을 의미하는 것이 아니라, 다수의 변수로 하기 힘든 작업을 배열을 통해 쉽게 할 수 있다.

* 1차원 배열 선언
  * 별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성
  * 이름 : 프로그램에서 사용할 배열의 이름
* 1차원 배열 접근
  * 인덱스를 사용하거나 변수를 사용해 접근 `arr[0]`

## 버블정렬

* 정렬
  * 2개 이상의 자료를 특정 기준에 따라 큰값 또는 그 반대로 재배열 하는 것

  * 키
    * 자료를 정렬하는 기준이 되는 특정 값

* 대표적인 정렬 방식
  * **버블 정렬**
  * 카운팅 정렬
  * **선택 정렬**
  * 퀵 정렬
  * 삽입 정렬
  * 병합 정렬

> 버블 정렬

* 인접한 두개의 원소를 비교하여 자리를 계속 교환하는 방식
* 정렬 과정
  1. 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환해 맨 마지막 자리까지 이동

  2. 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 이동됨
  
  3. 모두 정렬될 때까지 단계 반복

* 교환하며 자리 이동하는 모습이 물 위로 올라오는 거품 모양과 비슷해 거품정렬
* 시간복잡도 : O(n^2)

* 의사코드

    ```c
    bubbleSort(){
        ary[SIZE]
        for i = 1 to SIZE{
            for j = 1 to SIZE-i{
                if(ary[j-1] > ary[j])
                    swap(ary[j-1], ary[j])
            }
        }
    }
    ```

## 카운팅 정렬

* 순서를 정렬키 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 해, 선형 시간에 정렬하는 알고리즘

* 제한사항
  * 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
    * 각 항목 발생 횟수를 기록하기 위해 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문
  * 카운트들을 위한 충분한 공간을 할당하려면 집합 내 가장 큰 정수 알아야 함

* 시간 복잡도 : O(n + k) : n은 리스트 길이, k는 정수의 최대값

* 과정
  1. 데이터에서 각 항목들의 발생 횟수를 세고, 정수 항목으로 직접 인덱스 되는 카운트 배열에 저장한다.
  2. 정렬된 카운트 배열에서 각 항목의 앞에 위치할 항목 개수를 반영하기 위해 배열의 원소를 누적합으로 조정
  3. 원본 데이터를 순회하면서 카운트 배열에 값을 감소시키고 새 배열에 삽입

* 의사코드

  ```c
  // A 입력 배열 (0 to k)
  // B 정렬된 배열
  // C 카운트 배열
  Counting-Sort(A, B, k) {
    for i = 0 to k  // 배열 0으로 초기화
        C[i] = 0

    for j = 1 to length[A]  // 1. 발생횟수를 센다
        C[A[j]] = C[A[j]] + 1 
    
    for i = 1 to k  // 2. 배열의 원소를 누적합으로 바꿈
        C[i] = C[i] + C[i-1]
    
    for j = length[A] down to 1  // 3. B에 저장 후 다음 순서를 위해 C 감소
        B[C[A[j]]] = A[j]
        C[A[j]] = C[A[j]] - 1
    }
  ```

## 완전검색

* 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열하고 확인하는 방법
* Exaustive Search, Brute-force, 혹은 genearte-and-test 기법으로 불림
* 모든 경우의 수 테스트 하고 해법 도출
* 경우의 수가 상대적으로 적을 때 유용
* 수행 속도는 느리지만 해답 찾지 못할 확률 작음

## 그리디

* 탐욕 알고리즘은 최적해를 구할 때 사용하는 근시안적 방법
* 여러 경우중 하나를 선택해야 할 때마다 그 순간에 최적이라 생각되는 것을 선택해 나가는 방식으로 진행해 최종적인 해답에 도달
* 선택 시점에서 지역적 최적해이지만 결과가 최적이라는 보장은 없음
* 일반적으로 무지성으로 구현하면 greedy 접근

* 동작 과정
  1. 해 선택 : 현재 상태에서 부분 지역에 지역해를 구하고, 부분해 집합(solution set) 에 추가
  1. 실행 가능성 검사 : 새로운 부분해 집합이 실행가능한지 확인
  1. 해 검사 : 새로운 부분해 집합이 전체 문제의 해인지 확인, 아직 아니면 1번부터 다시 시작

* 전체 문제의 최적해를 찾지 못할 가능성도 있으니 주의
