# INDEX

* [2차원 배열](#2차원-배열)
  * [배열 순회](#배열-순회)
* [부분집합 생성](#부분집합-생성)
  * [비트](#비트-연산자)
* [검색](#search)
* [인덱스, 선택 정렬](#인덱스-선택-정렬)

> ## 2차원 배열

* 1차원 리스트를 묶은 리스트
* 다차원 리스트는 차원에 따라 Index 선언
* 2차원 리스트 선언: 행 개수, 열 개수 필요로 함
* Python 에서는 데이터 초기화를 통해 변수선언과 초기화가 가능

* ### 배열 순회

  * n X m 배열의 n*m개의 모든 원소를 빠짐없이 조사하는 방법

  > 행 우선 순회
  
  ```python
  # i 행의 좌표
  # j 열의 좌표
  for i in range(n):
    for j in range(m):
        array[i][j]  # 필요한 연산 수행
  ```
  
  > 열 우선 순회

  ```python
  # i 행의 좌표
  # j 열의 좌표
  for j in range(m):
      for i in range(n):
          array[i][j]  # 필요한 연산 수행
  ```
  
  > 지그재그 순회

  ```python
  # i 행의 좌표
  # j 열의 좌표
  for i in range(n):
      for j in range(m):
          array[i][j + (m-1-2*j) * (i%2)]  # 필요한 연산 수행
          # 짝수일때는 그대로 감, 홀수일때는 반대로 감
          # 2*j는 원래방향인거도 빼줘야 하니까
  ```

  > **델타를 이용한 2차 배열 탐색**

  * 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법
  * [ex](https://github.com/rlaehd12/TIL/blob/main/algorithm/search.py)

  > 활용 예시 : 전치행렬

  ```python
  # i : 행 좌표, len(arr)
  # j : 열 좌표, len(arr[0])
  arr = [[1,2,3],[4,5,6],[7,8,9]]  # 3*3 행렬

  for i in range(3):
      for j in range(3):
          if i < j:  # 우측상단에 있으면 맞바꾸기  # 우측하단 : i > j
              arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
  ```

  ![제목 없음](https://user-images.githubusercontent.com/122508528/216864000-86dc70f8-ad87-40aa-b603-16cf7a85d423.png)

> ## 부분집합 생성

* 집합의 원소가 n개일 때 공집합을 포함한 부분집합의 수는 $2^n$
* 집합의 각 원소를 포함, 포함x 인 경우를 모든 원소에 적용한 경우의 수
* [ex](https://github.com/rlaehd12/TIL/blob/main/algorithm/0206subset.py)

> ### **비트 연산자**

* 값은 메모리 안에 기본적으로 비트, 2진수 형태로 저장됨

* `<<` : 피연산자의 비트 열을 왼쪽으로 이동
  * `1<<3` : 1을 3번째 비트로 옮김 $1_2 -> 1000_2$ 그래서 $2^3$ = 8
  * `1<<n` : $2^n$ 즉 원소가 n개일 경우 모든 부분집합의 수 의미

    ```python
    print(1 << 3)  # 1 << 1000 즉 8     ## 1* 2^3
    print(2 << 3)  # 10 << 10000 즉 16  ## 2* 2^3
    print(5 << 1)  # 101 << 1010 10     ## 5* 2^1
    ```

  * 2진법으로 왼쪽으로 n칸씩 옮기는 거니까 $2^n$배씩 커짐

* `&` : 비트단위 and 연산
  * 둘다 1이면 1 반환, 아니면 0 반환
  
    ```python
    #   11001     # 즉 (25 & 14) = 8
    # & 01110
    # = 01000
    ```

  * `i & (1<<j)`
    * 1을 j번만큼 왼쪽으로 옮김
    * i의 j번째 비트가 1인지 아닌지 검사하는 연산

* `|` : 비트단위 or 연산
  * 둘다 0이면 0 반환, 아니면 1 반환

    ```python
    #   11001     # 즉 (25 | 14) = 31
    # | 01110
    # = 11111
    ```

* `>>` : 피연산자의 비트 열을 오른쪽으로 이동
  * `8>>1` : $1000_2$ 을 오른쪽으로 한칸 $100_2$ 즉 4가 된다

  ```python
  print(8 >> 1)  # 4
  print(8 >> 2)  # 2
  print(9 >> 1)  # 1001 >> 100 즉, 4
  ```

  * 오른쪽으로 이동할때 1보다 오른쪽으로 가면 그냥 없어짐

> 비트연산자 활용해 부분집합 생성

* [비트 연산자 활용 부분집합](https://github.com/rlaehd12/TIL/blob/main/algorithm/0206subset.py)

* 준비물

  ```python
  arr = ['Fish', 'And', 'Chips']
  N = len(arr)

  # arr 대한 모든 경우의 수
  for i in range(1 << N):  # 1을 왼쪽으로 N만큼
      # j: arr의 idx
      for j in range(N):
          if i & (1 << j):  # 1을 왼쪽으로 j만큼
              print(arr[j], end = ' ')
      print()
  ```

  <img src="https://raw.githubusercontent.com/rlaehd12/imagee/master/%EC%A0%9C%EB%AA%A9%20%EC%97%86%EC%9D%8C2.png" alt="drawing" width="300"/>

## Search

* 저장돼 있는 자료 중 원하는 항목 찾는 작업
* 목적하는 탐색 키를 가진 항목을 찾는 것
* 검색의 종류
  * 순차 검색
  * 이진 검색
  * 해쉬

> ### 순차 검색

* 일렬로 되어 있는 자료를 순서대로 검색하는 방법
  * 가장 간단하고 직관적 검색 방법
  * 배열, 연결 리스트 등 순차구조로 구현된 자료구조에서 원하는 항목을 찾을 때 유용함
  * 알고리즘이 단순해 구현이 쉽지만, 검색 대상의 수가 많은 경우 수행시간이 급격히 증가해 비효율적

* 2가지 경우: 정렬됨, 정렬 안됨

  > 정렬되지 않은 경우
  
  * 검색 과정
    * 첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾는다
    * 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환
    * 자료구조의 마지막까지 검색 대상 못찾으면 검색 실패

  * 찾고자 하는 원소의 순서에 따라 비교회수 결정됨

    * 첫번째 원소 찾을 때 1번, 2번째 찾을때 2번 비교...
    * 정렬되지 않은 자료에서 순차검색 평균 비교 회수
      * $ = (1/n)\times(1+2+3...+n)=(n+1)/2$
    * 시간복잡도 : $O(n)$
  * [구현 예시](https://github.com/rlaehd12/TIL/blob/main/algorithm/search.py)

  > 정렬된 경우

  * 자료를 순차적으로 검색하며 키 값을 비교
  * 원소의 키 값이 검색 대상 키 값보다 크면 원소가 없다는 것 - 더이상 검색하지 않고 검색 종료

  * 찾고자 하는 원소의 순서에 따라 비교회수 결정됨
    * 정렬되어 있어, 검색 실패를 반환하는 경우 평균 비교 회수가 반으로 줄음
  * 시간복잡도 : $O(n)$
  * [구현 예시](https://github.com/rlaehd12/TIL/blob/main/algorithm/search.py)

> ### 이진 검색

* 자료 가운데 항목 키 값과 비교해 다음 검색 위치 결정, 검색 계속 진행
  * 목적 키 찾을 때까지 이진 검색을 순환적으로 반복 수행해 검색 범위를 반으로 줄여가며 검색
* 이진 검색 하기 위해 자료 정렬된 상태여야 함

* 검색 과정
  * 자료 중앙 원소 고름
  * 중앙 원소와 목표 값 비교
  * 목표가 중앙보다 작으면 왼쪽, 크면 오른쪽에 대해 새로 검색 수행
  * 찾고자 하는 값 찾을 때까지 위 과정 반복

* 구현
  * 검색 범위의 시작점과 종료점을 이용해 검색을 반복 시행
  * 이진 검색의 경우, 자료 추가나 삭제가 이뤄졌을 때 배열 상태를 항상 정렬 상태로 유지하도록 추가 작업 필요
  * [구현 예시](https://github.com/rlaehd12/TIL/blob/main/algorithm/search.py)

## 인덱스, 선택 정렬

* 인덱스는 DB에서 유래했으며, 테이블에 대한 동작 속도를 높여주는 자료 구조를 일컫는다. DB 분야가 아닌 곳에서는 Look up table 등의 용어를 사용하기도 한다.
* 인덱스를 저장하는데 필요한 디스크 공간은 보통 테이블을 저장하는데 필요한 디스크 공간보다 작다. 보통 인덱스는 키-필드만 갖고 있고, 테이블의 세부 항목들은 갖고 있지 않기 때문에

* 배열 사용 인덱스
  * 대량의 데이터를 매번 정렬하면, 프로그램 반응은 느려질 수밖에 없음. 이러한 성능 저하 문제를 해결하기 위해 배열 인덱스 사용할 수 있다.

* 배열인덱스 추가 예시
  * 원본 데이터에 데이터가 삽입될 경우 상대적으로 크기 작은 인덱스 배열 정렬하기 때문에 속도 빠름

  <img src="https://user-images.githubusercontent.com/122508528/217122868-326f5723-065d-4256-a575-26421579b3c5.png" alt="drawing" width="550"/>

> 선택 정렬

* 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택해 위치 교환 방식
  * 셀렉션 알고리즘을 전체 자료에 적용한 것

* 정렬 과정
  * 주어진 리스트 중 최소값 찾는다

  * 그 값을 리스트 맨 앞 값과 교환

  * 맨 처음 위치 제외하고 나머지 리스트를 대상으로 위 과정 반복

* 시간복잡도 : $O(n^2)$

* 의사코드

  ```python
  def selectionsort(a[], n):
      for i from 0 to n-2
          a[i], .... ,a[n-1] 원소 중 최소값 a[k] 찾음
          a[i] 와 a[k] 교환
  ```

* [구현예시](https://github.com/rlaehd12/TIL/blob/main/algorithm/sorting.py)

> 셀렉션 알고리즘

* 저장되 있는 자료로부터 k번째 큰 혹은 작은 원소를 찾는 방법을 셀렉션 알고리즘이라 한다.
  * 최소값, 최대값 혹은 중간값을 찾는 알고리즘을 의미하기도 함

* 선택 과정
  * 정렬 알고리즘 이용해 자료 정렬
  * 원하는 순서에 있는 원소 가져오기

* k번째로 작은 원소 찾는 알고리즘
  * 1번부터 k번째까지 작은 원소들을 찾아 배열의 앞쪽으로 이동, 배열의 k번째 반환.
  * k가 비교적 작을 때 유용, O(kn)의 수행시간 필요로 한다.

* [구현예시](https://github.com/rlaehd12/TIL/blob/main/algorithm/sorting.py)