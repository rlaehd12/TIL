# INDEX

* 2차원 배열
* 부분집합 생성
* 바이너리 서치
* 셀렉션 알고리즘
* 선택 정렬

> ## 2차원 배열

* 1차원 리스트를 묶은 리스트
* 다차원 리스트는 차원에 따라 Index 선언
* 2차원 리스트 선언: 행 개수, 열 개수 필요로 함
* Python 에서는 데이터 초기화를 통해 변수선언과 초기화가 가능

* ### 배열 순회

  * n X m 배열의 n*m개의 모든 원소를 빠짐없이 조사하는 방법

  > 행 우선 순회
  
  ```python
  # i 행의 좌표
  # j 열의 좌표
  for i in range(n):
    for j in range(m):
        array[i][j]  # 필요한 연산 수행
  ```
  
  > 열 우선 순회

  ```python
  # i 행의 좌표
  # j 열의 좌표
  for j in range(m):
      for i in range(n):
          array[i][j]  # 필요한 연산 수행
  ```
  
  > 지그재그 순회

  ```python
  # i 행의 좌표
  # j 열의 좌표
  for i in range(n):
      for j in range(m):
          array[i][j + (m-1-2*j) * (i%2)]  # 필요한 연산 수행
          # 짝수일때는 그대로 감, 홀수일때는 반대로 감
          # 2*j는 원래방향인거도 빼줘야 하니까
  ```

  > **델타를 이용한 2차 배열 탐색**

  * 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법
  * [ex](https://github.com/rlaehd12/TIL/blob/main/algorithm/search.py)

  > 활용 예시 : 전치행렬

  ```python
  # i : 행 좌표, len(arr)
  # j : 열 좌표, len(arr[0])
  arr = [[1,2,3],[4,5,6],[7,8,9]]  # 3*3 행렬

  for i in range(3):
      for j in range(3):
          if i < j:  # 우측상단에 있으면 맞바꾸기  # 우측하단 : i > j
              arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
  ```

  ![제목 없음](https://user-images.githubusercontent.com/122508528/216864000-86dc70f8-ad87-40aa-b603-16cf7a85d423.png)

> ## 부분집합 생성

* 집합의 원소가 n개일 때 공집합을 포함한 부분집합의 수는 2^n
* 집합의 각 원소를 포함, 포함x 인 경우를 모든 원소에 적용한 경우의 수
* [ex](https://github.com/rlaehd12/TIL/blob/main/algorithm/0206subset.py)

> ### **비트 연산자**

* 값은 메모리 안에 기본적으로 비트, 2진수 형태로 저장됨

* `<<` : 피연산자의 비트 열을 왼쪽으로 이동
  * `1<<3` : 1을 3번째 비트로 옮김 1 -> 1000 그래서 2^3 = 8
  * `1<<n` : 2^n 즉 원소가 n개일 경우 모든 부분집합의 수 의미

    ```python
    print(1 << 3)  # 1 << 1000 즉 8     ## 1* 2^3
    print(2 << 3)  # 10 << 10000 즉 16  ## 2* 2^3
    print(5 << 1)  # 101 << 1010 10     ## 5* 2^1
    ```

  * 결국 2진법으로 왼쪽으로 n칸씩 옮기는 거니까 2배씩 커짐

* `&` : 비트단위 and 연산
  * 둘다 1이면 1 반환, 아니면 0 반환
  
    ```python
    #   11001     # 즉 (25 & 14) = 8
    # & 01110
    # = 01000
    ```

  * `i & (1<<j)`
    * 1을 j번만큼 왼쪽으로 옮김
    * i의 j번째 비트가 1인지 아닌지 검사하는 연산

* `|` : 비트단위 or 연산
  * 둘다 0이면 0 반환, 아니면 1 반환

    ```python
    #   11001     # 즉 (25 | 14) = 31
    # | 01110
    # = 11111
    ```

* `>>` : 피연산자의 비트 열을 오른쪽으로 이동
  * `8>>1` : 1000 을 오른쪽으로 한칸 100 즉 4가 된다

  ```python
  print(8 >> 1)  # 4
  print(8 >> 2)  # 2
  print(9 >> 1)  # 1001 >> 100 즉, 4
  ```

  * 오른쪽으로 이동할때 1보다 오른쪽으로 가면 그냥 없어짐

> 비트연산자 활용해 부분집합 생성

* [ex](https://github.com/rlaehd12/TIL/blob/main/algorithm/0206subset.py)

* 준비물

  ```python
  arr = ['Fish', 'And', 'Chips']
  N = len(arr)

  # arr 대한 모든 경우의 수
  for i in range(1 << N):  # 1을 왼쪽으로 N만큼
      # j: arr의 idx
      for j in range(N):
          if i & (1 << j):  # 1을 왼쪽으로 j만큼
              print(arr[j], end = ' ')
      print()
  ```

  <img src="https://raw.githubusercontent.com/rlaehd12/imagee/master/%EC%A0%9C%EB%AA%A9%20%EC%97%86%EC%9D%8C2.png" alt="drawing" width="300"/>
