# Index

* [계산기](#계산기)
* [백트래킹](#백트래킹)
* [부분집합, 순열](#부분집합-순열)
* [분할정복](#분할정복)

## 계산기

> 중위표기와 후위표기

* 중위표기법
  * 연산자를 피연산자 가운데에 표시하는 방법, `A+B`
* 후위표기법
  * 연산자를 피연산자 뒤에 표시하는 방법, `AB+`

> 중위표기식의 후위표기식 변환 방법1

* 수식의 각 연산자에 대해서 우선순위에 따라 괄호를 사용하여 다시 표현
* 각 연산자를 그에 대응하는 오른쪽괄호의 뒤로 이동
* 괄호 제거
* ex )  $A*B-C/D$
  1. $((A*B)-(C/D))$
  2. $((A B)* (C D)/)-$
  3. $AB*CD/-$

> 중위표기식의 후위표기식 변환 방법(스택 이용)2

1. 입력 받은 중위 표기식에서 토큰을 읽는다.

2. 토큰이 피연산자이면 토큰을 출력한다

3. 토큰이 연산자(괄호포함)일 때, 이 토큰이 스택의 top에 저장되어 있는 연산자보다 우선순위가 높으면 스택에 push하고, 그렇지 않다면 스택 top의 연산자의 우선순위가 토큰의 우선순위보다 작을 때까지 스택에서 pop한 후 토큰의 연산자를 push한다. 만약 top에 연산자가 없으면 push 한다.

4. 토큰이 오른쪽 괄호 ')'이면 스택 top 에 왼족 괄호 '(' 가 올때까지 스택에 pop 연산을 수행하고 pop한 연산자를 출력한다. 왼쪽 괄호를 만나면 pop만 하고 출력하지는 않는다.

5. 중위 표기식에 더 읽을 것이 없다면 중지하고, 더 읽을 것이 있다면 1부터 다시 반복한다.

6. 스택에 남아 있는 연산자를 모두 pop 하여 출력한다.
    * 스택 밖의 왼쪽 괄호는 우선순위가 가장 높으며, 스택 안의 왼쪽 괄호는 우선 순위가 가장 낮다.

> 후위 표기법의 수식을 스택 이용해 계산

1. 피연산자를 만나면 스택에 push한다.

2. 연산자를 만나면 필요한 만큼의 피연산자를 스택에서 pop하여 연산, 연산결과를 다시 스택에 push한다.

3. 수식이 끝나면, 마지막으로 스택을 pop하여 출력한다.


## 백트래킹

* Backtracking (백트래킹) 기법은 해를 찾는 도중에 '막히면' (해가 아니면) 되돌아가서 다시 해를 찾아 가는 기법
* 백트래킹 기법은 최적화 문제와 결정 문제를 해결 가능
* 결정 문제: 문제으 조건을 만족하는 해가 존재하는지의 여부를 'yes' 또는 'no'가 답하는 문제
  * 미로찾기, n-queen, map coloring, 부분집합의 합 문제 등

> 백트래킹과 깊이 우선탐색과의 차이

* 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄임, 가지치기/prunning

* 깊이우선탐색이 모든 경로를 추적하는데 비해 백트래킹은 불필요한 경로를 조기에 차단

* 깊이우선탐색을 가하기에는 경우의 수가 너무나 많음

* 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만 최악의 경우에는 여전히 지수함수 시간을 요함

> 백트래킹 기법

* 어떤 노드의 유망성을 점검한 후에 유망(promising)하지 않다고 결정되면 그 노드의 부모로 되돌아가(backtracking) 다음 자식 노드로 감

* 어떤 노드를 방문하였을 때 그 노드를 포함한 경로가 해답이 될 수 없으면 유망하지 않다 판단, 반대로 해답의 가능성이 있으면 유망하다고 한다

* pruning : 유망하지 않는 노드가 포함되는 경로는 더 이상 고려하지 않는다

  > 절차

  1. 상태 공간 트리의 깊이 우선 검색을 실시

  2. 각 노드가 유망한지 점검

  3. 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색을 계속한다

* 일반 백트래킹 알고리즘

  ```python
  def checknode(v) :
      if promising(v):
          if there is a solution at v:
              write the solution
          else:
              for u in each child of v:
                checknode(u)
  ```


> 미로 찾기

* 입구와 출구가 주어진 미로에서 입구부터 출구까지의 경로를 찾는 문제
* 이동할 수 있는 방향은 4방향으로 제한
  * 스택을 이용하여 지나온 경로를 역으로 되돌아 간다.

  * 스택을 이용해 다시 경로를 찾음


## 부분집합, 순열

* 어떤 집합의 공집합과 자기자신을 포함한 모든 부분집합을 powerset이라고 하며 구하고자하는 어떤 집합의 원소 개수가 n일 경우 부분집합의 개수는 $2^n$개 이다.

> 백트래킹 기법으로 powerset 구하기

* [구현 예시](https://github.com/rlaehd12/TIL/blob/main/algorithm/0216subset.py)

* 앞에서 설명한 일반적인 백트래킹 접근 방법을 이용

* n개의 원소가 들어있는 집합의 부분집합을 만들 때는, true 또는 false 값을 가지는 항목들로 구성된 n개의 배열을 만드는 방법을 이용.

* 여기서 배열의 i번째 항목은 i번째의 원소가 부분집합의 값인지 아닌지를 나타내는 값

> 순열

* [단순 순열 생성 예시](https://github.com/rlaehd12/TIL/blob/main/algorithm/0216permutation.py)

* 아직 안함
* [백트래킹을 이용한 순열 생성]()

## 분할정복

* 유래
  * 아수트리츠 전투에서 나폴레옹이 사용한 전략에서 유래

* 설계 전략
  * 분할(Divide) : 해결할 문제를 여러개의 작은 부분으로 나눈다.
  * 분할(Conquer) : 나눈 작은 문제를 각각 해결한다
  * 분할(Combine) : 필요하다면 해결된 해답을 모은다

> 거듭제곱

* $O(n)$

* 분할정복 기반 알고리즘 : $O(log_2n)$

> ### 퀵정렬

* 주어진 배열을 두개로 분할하고, 각각을 정렬

* 합병정렬과 다른점 1 : 합병정렬은 그냥 두 부분으로 나누는 반면, 퀵정렬은 분할할 때, 기준 아이템(pivot item) 중심으로, 이보다 작은 것은 왼편, 큰 것은 오른편에 위치
* 다른점 2 : 각 부분 정렬이 끝난 후, 합병정렬은 "합병" 이란 후처리 작업이 필ㅇ하나, 퀵정렬은 필요로 하지 않음

* 의사코드
  
  ```python
  def quickSort(a, begin, end):
      if begin < end:
          p = partition(a, begin, end)
          quickSort(a, begin, p-1)
          quickSort(a, p+1, end)
  
  def partition(a, begin, end):
      pivot = (begin + end) // 2
      L = begin
      R = end
      while L < R:  # 왼쪽이 오른쪽보다 커지기 전까지
          while(L<R and a[L]< a[pivot]): L += 1
          while(L<R and a[L]>=a[pivot]): R -= 1
          if L < R:
              if L == pivot : pivot = R
              a[L], a[R] = a[R], a[L]
      a[pivot], a[R] = a[R], a[pivot]
      return R
  ```

* 최악의 시간 복잡도는 $O(n^2)$ 로, 합병정렬에 비해 좋지 못함
* 하지만 평균 복잡도는 $nlogn$ 