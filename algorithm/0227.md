# INDEX

* [복잡도 분석](#복잡도-분석)
* [표준 입출력 방법](#표준-입출력-방법)
* [비트 연산](#비트-연산)
* [진수](#진수)
* [실수](#실수)

> 문제 해결 과정

* 문제를 읽고 이해
* 문제를 익숙한 용어로 재정의
* 어떻게 해결할지 계획 세우기
* 계획 검증
* 프로그램으로 구현
* 어떻게 풀었는지 돌아보고, 개선방법 찾기

## 복잡도 분석

* 알고리즘
  * 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법 주로 컴퓨터용어로 쓰이며 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말한다
  * 간단하게 어떠한 문제를 해결하기 위한 절차

* 알고리즘의 효율
  * 공간, 시간적 효율성
    * 공간적 효율성은 연산량 대비 얼마나 적은 메모리 공간을 요하는가
    * 시간적 효율성은 연산량 대비 얼마나 적은 시간을 요하는가
    * 효율성을 뒤집어 표현하면 복잡도(Complexity), 복잡도가 높을수록 효율성 저하
  
  * 시간적 복잡도 분석
    * 하드웨어 환경에 따라 처리시간 달라짐
      * 부동소수 처리 프로세서 존재유무, 나눗셈 가속기능 유무
      * 입출력 장비의 성능, 공유여부
    
    * 소프트웨어 환경에 따라
      * 프로그램 언어의 종류
      * 운영체제, 컴파일러의 종류
  
> 복잡도의 점근적 표기

* 시간, 공간 복잡도는 입력 크기에 따른 함수로 표현, 이 함수는 주로 여러개의 항을 가지는 다항식
* 이를 단순한 함수로 표기하기 위해 점근적 표기(Asymptotic Notation)를 사용
* 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표기하기 위해 사용

* > big O 표기
  
  * o 표기는 복잡도의 점근적 상한을 나타낸다
  * 복잡도가 $f(n) = 2n^2-7n+4$ 라면 $O(n^2)$
  * 단순화된 함수 n^2 에 임의의 사수 c를 곱한 cn^2 이 n이 증가함에 따라 함수의 상한이 된다.

* > $\Omega$ Big omega 표기
  
  * 복잡도의 점근적 하한을 의미
  * $f(n) = 2n^2-7n+4$ 라면 $\Omega(n^2)$
  * 최소한 이만한 시간은 걸린다는 표기

* > $\Theta$ theta 표기
  
  * O와 Omega표기가 같은 경우 사용

## 표준 입출력 방법

* 입력
  * Raw 값의 입력: input()
    * 받은 입력값을 문자열로 취급
  
  * Evaluated 된 값 입력: eval(input())
    * 받은 입력값을 평가된 데이터 형으로 취급

* 출력
  * `print('%d' %number)`
    * formatting 된 출력

## [비트 연산](https://github.com/rlaehd12/TIL/blob/main/algorithm/0206.md#비트-연산자)

* 연산자

  <img src = https://user-images.githubusercontent.com/122508528/221462918-1c59b58e-2b32-429c-a07d-6478ccf0608e.png width= 500>
  <img src = https://user-images.githubusercontent.com/122508528/221463068-279d0a85-5481-4aae-add2-a03aa5bd0aca.png width = 500>

> 엔디안(Endianness)

* 컴퓨터의 메모리와 같은 1차원의 공간에 여러개의 연속된 대상을 배열하는 방법을 의미, HW 아기텍처마다 다름
* 속도 향상을 위해 바이트단위와 워드 단위를 변환하여 연산할 때 올바로 이해하지 않으면 오류 발생 가능

* 엔디안은 크게 두가지로 나눔
  * 빅 엔디안 - 보통 큰 단위가 앞에 나옴, 네트워크
  * 리틀 엔디안 - 작은 단위가 앞에 나옴, 대다수 데스크탑 컴퓨터

## 진수

* 10진수 - 다른 진수로 변환
  * 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽는다
  * $149_{10} = 10010101_2 = 225_8 = 95_{16}$

* 컴퓨터에서의 음의 정수 표현
  * 1의 보수: 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0으로 변환
    * -6 : 1000000000000110 : 부호와 절대값 표현(최상위 비트 하나를 양수,음수로 정함)
    * -6 : 1111111111111001 : 1의 보수 표현

  * 2의 보수 : 1의 보수방법으로 표현된 값의 최하위 비트에 1을 더함
    * -6 : 1111111111111010 : 2의 보수 표현
    * 2의 보수는 그냥 더해버리면 값이 나옴
      * $-5 = 11111011_2, 3 = 00000011_2 / -5+3 = -2 = 11111101_2$

## 실수

* 컴퓨터는 실수를 표현하기 위해 부동 소수점(floating-point) 표기법을 사용
* 부동 소수점 표기 방법은 소수점의 위치를 고정시켜 표현하는 방식
  * 소수점 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현
    * $1001.0011 \rarr 1.0010011 \times 2^3$

* 실수를 저장하기 위한 형식
  * 단정도 실수(32비트)
  * 배정도 실수(64비트)

    <img src = https://user-images.githubusercontent.com/122508528/221729100-f9252b19-d3df-4437-9c07-d2db4674b60c.png width = 500>
  
  * 가수부(mantissa) : 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것
  * 지수부(exponent) : 실제 소수점의 위치를 지수 승으로 표현한 것

  > 단정도 실수의 가수 부분을 만드는 방법

  * 예) 1001.0011
    * 정수부의 첫번째 자리가 1이 되도록 오른쪽으로 시프트
    * 소수점 이하를 23비트로 만든다
    * 소수점 이하만을 가수 부분에 젖아
    * 지수 부분은 시프트 한 자릿수만큼 증가 또는 감소
  
  * 지수부에는 8비트가 배정, 256개의 상태 나타낼 수 있음
  * 숫자로는 0-255 까지 나타낼 수 있지만, 음수 값을 나타낼 수 있어야 하므로 익세스 표현법을 사용
    * 익세스 표현법 : 지수부의 값을 반으로 나누어 그 값을 0으로 간주하여 음수지수와 양수지수를 표현하는 방법

* 컴퓨터는 실수를 근사적으로 표현
  * 이진법으로 표현 할 수 없는 형태의 실수는 정확한 값이 아니라 근사 값으로 저장되는데 이때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져옴
  * 실수 자료형의 유효 자릿수를 알아 두자(대략)
    * 32비트 실수형 유효자릿수 (십진수) - 6
    * 64비트 실수형 유효자릿수 (십진수) - 15

* 파이썬에서의 실수 표현 범위
  * 파이썬에서는 내부족으로 더 많은 비트를 사용해서 훨씬 넓은 범위의 실수 표현 가능
  * 최대로 표현할 수 있는 값은 약 $1.8 \times 10^{308}$ 이고 이 이상은 inf로 표현
  * 최소로 표현할 수 있는 값은 약 $5.0 \times 10^{-324}$, 이 이하는 0으로 표현
