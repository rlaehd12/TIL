# 데이터

## 데이터베이스

* SQL VS NoSQL
  * NoSQl은 SQL에 비해 훨씬 확장성이 용이함
  * 분산을 위해 사용, 기존 RDB는 관리가 좀 불편함
  * 그래도 일반적으로 메인 DB는 RDB 많이 사용

### 관계형 DB(RDB)

* 데이터를 테이블, 행, 열 등으로 나누어 구조화 하는 방식
* 보다 체계적으로 데이터를 저장, 관리 가능
* 자료를 여러 테이블로 나누어 관리, 테이블간 관계 설정해 여러 데이터 조작 가능
* 데이터의 무결성(정확성, 일관성) 유지에 장점
* SQL을 사용해 데이터를 조회하고 조작

> RDB 구조

* 스키마
  * 테이블의 구조(structure)
  * 데이터베이스에서 자료의 구조, 표현 방법, 관계 등 전반적인 명세를 기술한 것
* 테이블
  * 필드와 레코드를 사용해 조작된 데이터 요소들의 집합
  * 관계(relation) 라고도 부름
  * 필드
    * 속성, 컬럼
    * 각 필드에는 고유한 데이터 타입이 지정됨
  * 레코드
    * 튜플, 행
    * 테이블의 데이터는 레코드에 저장
  * 키
    * PK
      * 각 레코드의 고유한 값
      * 기술적으로 다른 항목과 절대 중복 될 수 없는 단일 값(unique)
    * FK
      * 한 테이블의 속성 중 다른 테이블의 레코드를 식별할 수 있는 키
      * 다른 테이블 기본 키 참조
      * 참조하는 테이블의 속성 1개 값은, 참조되는 측 테이블의 레코드 값에 대응
      * 각 레코드에서 서로 다른 테이블 간의 관계를 만드는 데 사용 가능

* DBMS
  * 데이터베이스를 쉽게 조작할 수 있게 하는 소프트웨어

## SQL

* SQL commands 종류

  ![image](https://user-images.githubusercontent.com/122508528/229953965-ba26827d-918f-4868-92d0-ad6ccbca5b80.png)

* SQL syntax(문법)
  * 모든 SQL 문(statement)는 SELECT, INSERT 등과 같은 키워드로 시작, 하나의 statement는 세미콜론으로 끝남
  * SQL 키워드는 대소문자 구분하지 않음
    * 키워드 대문자로 작성 권장
  * statement(문)
    * 독립적으로 실행할 수 있는 완전한 코드 조각
    * statement는 clause로 구성
  * clause(절)
    * statement 하위 단위

    ![image](https://user-images.githubusercontent.com/122508528/229955399-665c66a1-3b65-4ce6-96ea-595902527d12.png)

> sqlite Data Types

* NULL
* INTEGER
  * 크기에 따라 8바이트까지 가변 크기 가짐
* REAL
  * 8바이트 부동 소수점을 사용하는 10진수 값이 있는 실수
* TEXT
* BLOB(Binary Large Object)
  * 입력된 그대로 저장된 데이터 덩어리(대용 타입 없음)
  * 바이너리 등 멀티미디어 파일
    * 이미지 데이터 등
* sqlite에는 별도의 Boolean 타입 없음, 대신 0(false), 1(true)로 저장
* sqlite에는 날짜 및 시간 저장하기 위한 타입 없음
* Binary Data
  * 데이터의 저장과 처리를 목적으로 이진 형식으로 인코딩 된 파일
  * 기본적으로 컴퓨터의 모든 데이터는 바이너리 데이터
    * 다만 이를 필요에 따라 텍스트 타입으로 변형해 사용하는 것

* Type Affinity(타입 선호도)
  * 특정 컬럼에 저장된 데이터에 권장되는 타입
  * sqlite 5가지 데이터 타입 외 다른 데이터 타입 선언하면 sqlite 내부적으로 알아서 5가지 데이터 타입으로 인식
  * 존재 이유
    * 다른 DB 엔진간의 호환성 최대화
    * 정교한 DB SQL문을 sqlite에서 간단하게 작동하게 하기 위함

> constraints

* 입력하는 자료에 대한 제약 정함
* 데이터 무결성 유지하기 위한 보편적인 방법, 테이블의 특정 컬럼에 설정하는 제약
* **데이터 무결성**
  * 데이터 베이스 내의 데이터에 대한 정확성, 일관성을 보장하기 위해 데이터 변경 혹은 수정 시 여러 제한을 두어 데이터의 정확성을 보증
  * DB에 저장된 데이터의 무결성을 보장, DB 상태를 일관되게 유지하는 것이 목적
* constraints 종류
  * `NOT NULL`
    * NULL값 허용 안함, 기본값은 당연히 허용
  * `UNIQUE`
    * 모든 값이 고유한 값이 되도록
  * `PRIMARY KEY`
  * `AUTOINCREMENT`
    * 이전에 삭제된 행의 값 재사용 방지
    * 장고에서 테이블 생성 시 id컬럼에 기본적으로 적용되는 제약
  * rowid
    * sqlite에서 테이블 생성할 때마다 rowid라는 암시적 자동 증가 컬럼이 자동으로 생성
    * PK역할 하는 64비트 부호 있는 정수 값
    * 값은 1에서 시작
    * 데이터 삽입 시 rowid 또는 `INTEGER PRIMARY KEY` 컬럼에 명시적으로 값이 지정되지 않은 경우, sqlite는 테이블에서 가장 큰 rwoid보다 하나 큰 다음 순차 정수를 자동으로 할당(`AUTOINCREMENT` 상관 없이)
    * 만약 PK 컬럼을 직접 만들면 이 컬럼은 rowid 컬럼의 별칭(alias)이 됨
      * 즉, 새 컬럼 이름으로 rowid에 액세스 가능, rowid 이름으로도 여전히 액세스 가능
    * 데이터가 최대 값에 도달하고 새 행 삽입하려 하면 sqlite는 사용되지 않는 정수 찾아 사용
    * 만약 sqlite가 사용되지 않은 정수를 찾을 수 없으면 에러 발생
      * 또한 일부 행을 삭제하고 새 행을 삽입하면 sqlite는 삭제된 행에서 rowid 값을 재사용하려고 시도
  * `DEFAULT`
    * 데이터를 추가할 때 값을 생략할 시에 기본 값 설정

> ALTER, DROP TABLE

* `ALTER TABLE` 기존 테이블의 구조를 수정(변경)
  * 기존 테이블을 다음과 같이 변경 가능
    * **Rename** table, column
    * **Add** column
      * 이전에 이미 저장된 데이터들은 새롭게 추가되는 컬럼에 값이 없기 때문에 NULL 작성, NOT NULL 제약조건이 있다면 기본 값 없이는 추가될 수 없다는 에러 발생
    * **Delete** column
      * 삭제하지 못하는 경우
        * 컬럼이 다른 부분에서 참조되는 경우, `FOREIGN KEY` 제약조건 등
        * PK인 경우
        * UNIQUE 제약이 있는 경우
* `DROP` DB에서 테이블 제거
  * 한 번에 하나의 테이블만 삭제
  * 한번 실행하면 복구 불가

### DML

* Sorting NULLs
  * 정렬과 관련해 sqlite는 NULL을 다른 값보다 작은 것으로 간주

* NULL with DISTINCT
  * sqlite는 NULL값을 중복으로 간주

* sqlite logical operators(논리연산자)
  * 일부 표현식의 truth를 테스트 할 수 있음
  * 1,0 또는 널값 반환
  * sqlite는 불린 데이터 타입을 제공하지 않으므로 1은 true, 0은 false
  * ALL, AND, ANY, BETWEEN, IN, LIKE 등...

* `LIKE` 연산자
  * 패턴 일치를 기반으로 데이터 조회
  * WHERE 절에서 사용
  * 기본적으로 대소문자 구분하지 않음
    * `'A' LIKE 'a'` 는 true
  * sqlite는 패턴 구성 위해 두 개 와일드 카드 제공
    * `%`(percent)
      * 0개 이상의 문자가 올 수 있음을 의미
    * `_`(underscore)
      * 단일 문자가 있음을 의미
* "wildcards" character
  * 파일을 지정할 때, 구체적인 이름 대신 여러 파일을 동시에 지정할 목적으로 사용하는 특수 기호, `*`, `?` 등
  * 주로 특정 패턴 있는 문자열 혹은 파일을 찾거나, 긴 이름 생략할 때 쓰임
  * 지정된 패턴 일치 기반으로 데이터 수집하는데 도움이 될 수 있음

* `IN` 연산자
  * 값이 값 목록 결과에 있는 값과 일치하는지 확인
  * 표현식이 값 목록의 값과 일치하는지 여부에 따라 true 또는 false 반환
* `BETWEEN` 연산자
  * 값이 값 범위에 있는지 테스트
  * 지정된 범위에 있으면 true
  * `WHERE`절에서 사용
* `LIMIT` 절
  * 쿼리에서 반환되는 행 수 제한
* `OFFSET` 키워드
  * 리미트 절을 사용하면 첫 번째부터 지정된 수만큼 데이터를 받을 수 있지만 OFFSET과 함께 쓰면 특정 지정된 위치에서부터 데이터 조회 가능

  ![image](https://user-images.githubusercontent.com/122508528/229968642-51e04383-796e-47b7-8d44-473ea85bf7ac.png)
