<header>
  <style>
    #back_yellow{
        background-color:yellow;
        color: black;
    }
  </style>
</header>

# INDEX

- [INDEX](#index)
  - [Django 시작](#django-시작)
  - [클라이언트와 서버](#클라이언트와-서버)
  - [가상환경](#가상환경)
  - [프로젝트와 앱](#프로젝트와-앱)
  - [요청과 응답](#요청과-응답)

## Django 시작

* 장고와 스프링
  * 장고 - 다소 독선적
    * 확실한 규칙 - 올바르게 사용하기 위한 메뉴얼
  * 스프링 - 관용적

> Framework 이해

* 누군가 만들어 놓은 코드를 재사용하는 것은 익숙한 개발 문화
* 웹 서비스도 개발된 코드를 재사용하면 된다
* <span id='back_yellow'>서비스 개발에 필요한 기능들을 미리 구현해서 모아 놓은 것 = 프레임워크</span>
* Frame(뼈대, 틀) + Work(일하다)
  * 일정한 뼈대, 틀을 가지고 일하다
  * 제공받은 도구들과 뼈대, 규약을 가지고 무언가를 만드는 일
  * 특정 프로그램을 개발하기 위한 여러 도구들과 규약을 제공하는 것
* "소프트웨어 프레임워크"는 복잡한 문제를 해결하거나 서술하는 데 사용되는 기본 개념 구조
* Framework를 잘 사용하면 서비스 개발에 있어 모든 것들을 직접 개발할 필요 없이, 내가 만들고자 하는 본질(로직)에 집중 할 수 있음
* 소프트웨어의 생산성과 품질을 높임

* 단점
  * 러닝커브(학습 곡선)이 존재
  * 선택의 폭이 좁아짐

## 클라이언트와 서버

> 클라이언트-서버 구조

* 오늘날 우리가 사용하는 대부분의 웹 서비스는 클라이언트-서버 구조를 기반으로 동작
* 클라이언트와 서버 역시 하나의 컴퓨터, 이들의 상호작용에 대한 간소화된 다이어그램

  <img src = https://user-images.githubusercontent.com/122508528/224861983-ecf316a9-d08f-4264-937d-8670a816f519.png width=400>

* 클라이언트
  * 웹 사용자의 인터넷에 연결된 장치(wifi에 연결된 컴퓨터 또는 모바일)
  * 크롬 또는 파이어폭스와 같은 웹 브라우저
  * 서비스를 요청하는 주체
  * 받은 파일을 해석(렌더링)함
* 서버
  * 웹 페이지, 사이트 또는 앱을 저장하는 컴퓨터
  * 클라이언트가 웹 페이지에 접근하려 할 때 서버에서 클라이언트 컴퓨털 웹 페이지 데이터를 응답해 사용자의 웹 브라우저에 표시됨
  * 요청에 대해 서비스를 응답하는 주체
* 상호작용 예시
  * 우리가 구글 홈페이지에 접속하려 할 때
  1. 인터넷에 연결된 어딘가에 구글 컴퓨터에 '구글홈페이지.html' 파일을 달라고 요청하는 것

  2. 구글 컴퓨터는 요청을 받고 파일을 인터넷을 통해 우리 컴퓨터에 응답해줌

  3. 전달받은 구글홈페이지.html 파일을 웹 브라우저가 우리가 볼 수 있도록 해석(렌더링)해줌

  * 여기서 구글홈페이지.html 을 달라고 요청한 컴퓨터, 웹 브라우저를 <span id='back_yellow'>클라이언트</span>라고 하고 파일을 제공한 컴퓨터, 프로그램을 <span id='back_yellow'>서버</span>라고 함

  * 어떠한 자원을 달라고 요청하는 쪽을 클라이언트, 자원을 제공해주는 쪽을 서버

> 요약

* 우리가 사용하는 웹은 대부분 클라이언트-서버 구조로 이루어져 있음
* 이 중에서 Django는 서버를 구현하는 웹 프레임워크
* 장고 - DB와 소통하면서 응답을 줌
  * 점점 버거워져서 장고는 DB와 소통하고 데이터만 받고 클라이언트에게 넘김
  * 서버의 역할만 맡음
* vue - 받은 데이터를 가지고 웹 페이지를 만듬

## 가상환경

> 패키지와 가상환경

* 가상환경은 프로젝트별 패키지를 독립적으로 관리하기 위한 것
  
> 가상환경 사용하기

* 가상환경 생성
  * `python -m venv venv`
  * 맨 뒤는 파일 이름, 보통 venv로 사용
* 가상환경 활성화
  * `source venv/scripts/activate`
  * venv폴더 안에 스크립츠 안에 activate파일이 있음
* 가상환경 비활성화
  * `deactivate`
* 가상환경 패키지 목록 저장
  * `pop freeze > requirements.txt`
* 파일로부터 패키지 설치
  * `pip install -r requirements.txt`

## 프로젝트와 앱

> 장고 프로젝트 구조

* `__init__.py`
  * python에게 이 디렉토리르 하나의 파이썬 패키지로 다루도록 지시
* `asgi.py`
  * Asynchronous server gateway interface
  * 장고 애플리케이션이 비동기식 웹 서버와 연결 및 소통하는 것을 도움
  * 추후 배포시에 사용
* `settings.py`
  * 장고 프로젝트 설정을 관리
* `urls.py`
  * url - 서버로 요청할 요청의 형태
  * 사이트의 url과 적절한 views의 연결을 지정
  * 어떤 url로 들어왔을때 어떻게 처리할 것인지
* `wsgi.py`
  * web server gateway interface
  * 장고 애플리케이션이 웹서버와 연결 및 소통하는 것을 도움
  * 추후 배포시에 사용
* `manage.py`
  * 장고 프로젝트와 다양한 방법으로 상호작용하는 커맨드라인 유틸리티

> 장고 애플리케이션(프로젝트와 같은 레벨에 존재)

* 앱 생성
  * `python manage.py startapp articles`
  * 일반적으로 애플리케이션 이름은 복수형으로 작성하는 것을 권장
* 앱 == 하나의 큰 기능 단위
  * 정해진 규칙은 없으며 개발자가 판단해 앱 생성, 여러개의 앱이 아닌 단일 앱으로 개발해도 괜찮음

* `admin.py`
  * 관리자용 페이지를 설정 하는 곳
* `apps.py`
  * 앱의 정보가 작성된 곳
  * 별도로 추가 코드 작성하지 않음
* **`models.py`**
  * 애플리케이션에서 사용하는 모델을 정의하는 곳
  * MTV 패턴의 M에 해당
* `test.py`
  * 프로젝트의 테스트 코드를 작성하는 곳
  * 서버 안띄우고 테스트
* `views.py`
  * view 함수들이 정의 되는 곳
  * MTV 패턴의 V에 해당
* <span id='back_yellow'>앱을 사용하기 위해서는 반드시 **앱을 추가 한 후** `settings.py` 안에 INSTALLED_APPS 리스트에 추가해야 함</span>
  * 리스트에 추가하고 프로젝트에 앱을 추가하면 에러 발생 가능
    * 장고가 이미 있는 앱을 추가한다고 판단할 수 있음
  
  <img src = https://user-images.githubusercontent.com/122508528/224880739-1d110110-419b-4c71-bffb-7b0a69ec7aae.png width=250>

> 프로젝트와 앱

* project
  * collection of apps
  * 프로젝트는 앱의 집합
  * 프로젝트는 여러 앱이 포함될 수 있음
  * 앱은 여러 프로젝트에 있을 수 있음
* application
  * 앱은 실제 요청을 처리하고 페이지를 보여주는 등의 역할을 담당
  * 앱은 하나의 역할 및 기능 단위로 작성하는 것을 권장함

## 요청과 응답

* <span id='back_yellow'>코드 작성의 순서</span>
  1. urls.py
  2. views.py
  3. templates
  * 데이터의 흐름
  * 디버깅 시간 감소
    * url 못찾는 에러 많이 발생하게 될 것

* [장고의 세가지 구조 MTV](https://github.com/rlaehd12/TIL/blob/main/web/0315.md#index)
  * model
  * view
  * template
    * 실제 내용을 보여주는데 사용되는 파일
    * 파일의 구조나 레이아웃을 정의
    * 템플릿 파일의 기본 경로
      * app 폴더 안의 templates vhfej
      * `app_name/templates/app_name`
      * <span id='back_yellow'>템플릿 폴더 이름은 반드시 `templates` 라고 지정해야 함</span>

* `render()`
  * `render(request, template_name, context)`
  * 주어진 템플릿을 주어진 컨텍스트 데이터와 결합하고 렌더링 된 텍스트와 함께 HttpResponse(응답) 객체를 반환하는 함수
  
  1. request
      * 응답을 생성하는 데 사용되는 요청 객체
  2. template_name
      * 템플릿의 전체 이름 또는 템플릿 이름의 경로
  3. context
      * 템플릿에서 사용할 데이터(딕셔너리 타입으로 작성)

